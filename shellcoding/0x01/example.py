#!/usr/bin/env python3
#
# This is an example script to help you setup for solving these challenges. 
# If any questions or issues, contact nordbo on Discord.

from pwn import *

exe = context.binary = ELF('./sc01')

host = args.HOST or 'io.ept.gg'
port = int(args.PORT or 30011)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# we break at the function that calls our shellcode.
gdbscript = '''
b *runShellcode
continue
'''.format(**locals())

# The code below is just an example to get you started. It just writes a string to stdout. You need to create your own shellcode to solve the challenge.

# We can use the shellcraft module of pwntools to create shellcode for us.
# Shellcraft documentation: https://docs.pwntools.com/en/stable/shellcraft/amd64.html
string_code = (shellcraft.pushstr("Welcome to the shellcoding challenges!\nTry to spawn a shell, or read /opt/flag\n"))

# We can also write aseembly by hand. The line above will create automatically create shellcode that pushed the given string on to the stack. 
# the code below will setup two syscalls. First write the string from above to stdout, then exit the program. 

asm_code = """
    push rsp;       # move we push rsp (the stack pointer) to the stack
    pop rsi;        # move the pointer to our string into rsi
    mov rax, 1;     # we want to call the WRITE syscall, so rax needs to be 1. See https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/
    mov rdi, 1;     # we want to write to STDOUT, which is fd 1
    mov  rdx, 80;   # the length of our string
    syscall;        # invoke the write syscall
    mov rax, 60;    # syscall 60 is exit
    mov rdi, 1;     # exit with statuscode 1
    syscall;        # invoke the exit syscall
"""

# We can also use the print function to see the shellcode generated by shellcraft
print(string_code)
# And we can print the shellcode we created ourself
print(asm_code)
shellcode = string_code + asm_code
# initialize the connection to the server, OR run the program locally. 
io = start()
# we want to receieve all the text printed by the program. 
print(io.recvuntil(b'>'))
# lets compile our assembly into bytes. 
binaryCode = asm(shellcode)

# Send the binary shellcode to the server
io.sendline(binaryCode)

# read the result back, and print it. We can also use io.interactive() to get a interactive socket to the server. 
print(io.recvline().decode('ascii'))
print(io.recvline().decode('ascii'))

# Close the connection
io.close()

# There are several ways to run this program
# ./solve.py LOCAL < run it locally
# ./solve.py LOCAL GDB < run locally and attach to gdb
# ./solve.py REMOTE < connect to the remote instance and run shellcode there.